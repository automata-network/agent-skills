#!/usr/bin/env python3
"""
Playwright Web Testing Script - Enhanced Edition with Auto-Discovery
Automatically generated by Claude Code skill
"""

import asyncio
import argparse
import json
import yaml
from datetime import datetime
from pathlib import Path
from playwright.async_api import async_playwright
from typing import List, Dict, Any, Optional, Set
from PIL import Image, ImageChops, ImageDraw
from urllib.parse import urljoin, urlparse
import hashlib
import re
import os
from dataclasses import dataclass
from typing import Tuple

# Device presets
DEVICE_PRESETS = {
    "iphone_13": {"width": 390, "height": 844, "device_scale_factor": 3, "is_mobile": True, "has_touch": True,
                  "user_agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15"},
    "iphone_13_pro": {"width": 390, "height": 844, "device_scale_factor": 3, "is_mobile": True, "has_touch": True,
                      "user_agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15"},
    "iphone_13_pro_max": {"width": 428, "height": 926, "device_scale_factor": 3, "is_mobile": True, "has_touch": True,
                          "user_agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15"},
    "ipad_air": {"width": 820, "height": 1180, "device_scale_factor": 2, "is_mobile": True, "has_touch": True,
                 "user_agent": "Mozilla/5.0 (iPad; CPU OS 15_0 like Mac OS X) AppleWebKit/605.1.15"},
    "ipad_pro": {"width": 1024, "height": 1366, "device_scale_factor": 2, "is_mobile": True, "has_touch": True,
                 "user_agent": "Mozilla/5.0 (iPad; CPU OS 15_0 like Mac OS X) AppleWebKit/605.1.15"},
    "pixel_5": {"width": 393, "height": 851, "device_scale_factor": 2.75, "is_mobile": True, "has_touch": True,
                "user_agent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36"},
    "galaxy_s21": {"width": 360, "height": 800, "device_scale_factor": 3, "is_mobile": True, "has_touch": True,
                   "user_agent": "Mozilla/5.0 (Linux; Android 11; Galaxy S21) AppleWebKit/537.36"},
    "desktop_1080p": {"width": 1920, "height": 1080, "device_scale_factor": 1, "is_mobile": False, "has_touch": False},
    "desktop_1440p": {"width": 2560, "height": 1440, "device_scale_factor": 1, "is_mobile": False, "has_touch": False},
}

# Network presets
NETWORK_PRESETS = {
    "slow_3g": {"download_mbps": 0.5, "upload_mbps": 0.5, "latency_ms": 2000},
    "fast_3g": {"download_mbps": 1.6, "upload_mbps": 0.75, "latency_ms": 562.5},
    "slow_4g": {"download_mbps": 4, "upload_mbps": 3, "latency_ms": 400},
    "fast_4g": {"download_mbps": 20, "upload_mbps": 10, "latency_ms": 150},
    "offline": {"offline": True},
}


@dataclass
class UIElement:
    """Represents a UI element found in source code"""
    element_type: str  # button, link, input, etc.
    selector: str
    text: str
    file_path: str
    line_number: int
    attributes: Dict[str, str]

    def get_identifier(self) -> str:
        """Get a unique identifier for this element"""
        return f"{self.element_type}:{self.selector or self.text}"


class CodeAnalyzer:
    """Analyze source code to find all UI elements for coverage validation"""

    def __init__(self, source_dir: str):
        self.source_dir = Path(source_dir)
        self.ui_elements: List[UIElement] = []

    def analyze(self) -> List[UIElement]:
        """Analyze all source files to find UI elements"""
        print(f"\nüîç Analyzing source code in: {self.source_dir}")

        if not self.source_dir.exists():
            print(f"‚ö† Source directory not found: {self.source_dir}")
            return []

        # Find all relevant source files
        patterns = ['**/*.html', '**/*.jsx', '**/*.tsx', '**/*.js', '**/*.ts', '**/*.vue']
        for pattern in patterns:
            for file_path in self.source_dir.glob(pattern):
                self._analyze_file(file_path)

        print(f"‚úì Found {len(self.ui_elements)} UI elements in source code\n")
        return self.ui_elements

    def _analyze_file(self, file_path: Path):
        """Analyze a single file for UI elements"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')

            # HTML/JSX/TSX interactive element patterns
            element_patterns = [
                # Buttons
                (r'<button([^>]*)>(.*?)</button>', 'button'),
                (r'<input\s+type=["\']button["\']([^>]*)', 'button'),
                (r'<input\s+type=["\']submit["\']([^>]*)', 'button'),
                (r'role=["\']button["\']', 'button'),
                (r'className=["\'][^"\']*button[^"\']*["\']', 'button'),
                (r'className=["\'][^"\']*Button[^"\']*["\']', 'button'),

                # Links
                (r'<a([^>]*)>(.*?)</a>', 'link'),

                # Inputs
                (r'<input\s+type=["\']text["\']([^>]*)', 'input'),
                (r'<input\s+type=["\']email["\']([^>]*)', 'input'),
                (r'<input\s+type=["\']password["\']([^>]*)', 'input'),
                (r'<input\s+type=["\']search["\']([^>]*)', 'input'),
                (r'<input\s+type=["\']tel["\']([^>]*)', 'input'),
                (r'<input\s+type=["\']url["\']([^>]*)', 'input'),
                (r'<input(?!\s+type=)([^>]*)', 'input'),  # input without type
                (r'<textarea([^>]*)', 'textarea'),

                # Checkboxes and Radios
                (r'<input\s+type=["\']checkbox["\']([^>]*)', 'checkbox'),
                (r'<input\s+type=["\']radio["\']([^>]*)', 'radio'),

                # Select dropdowns
                (r'<select([^>]*)', 'select'),

                # Tabs
                (r'role=["\']tab["\']', 'tab'),
                (r'className=["\'][^"\']*tab[^"\']*["\']', 'tab'),

                # Accordions
                (r'<summary([^>]*)', 'accordion'),
                (r'aria-expanded=["\']', 'accordion'),
                (r'className=["\'][^"\']*accordion[^"\']*["\']', 'accordion'),

                # Toggles/Switches
                (r'role=["\']switch["\']', 'toggle'),
                (r'className=["\'][^"\']*toggle[^"\']*["\']', 'toggle'),
                (r'className=["\'][^"\']*switch[^"\']*["\']', 'toggle'),

                # Modals
                (r'data-toggle=["\']modal["\']', 'modal-trigger'),
                (r'data-bs-toggle=["\']modal["\']', 'modal-trigger'),
                (r'aria-haspopup=["\']dialog["\']', 'modal-trigger'),

                # Menu items
                (r'role=["\']menuitem["\']', 'menu-item'),
                (r'className=["\'][^"\']*menu-item[^"\']*["\']', 'menu-item'),

                # Generic clickable
                (r'onClick\s*=\s*[{(]', 'clickable'),
            ]

            for line_num, line in enumerate(lines, 1):
                for pattern, element_type in element_patterns:
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    for match in matches:
                        # Extract attributes
                        attrs = self._extract_attributes(match.group(0))
                        text = match.group(2) if match.lastindex >= 2 else attrs.get('value', '')

                        # Build selector
                        selector = self._build_selector(attrs, element_type)

                        element = UIElement(
                            element_type=element_type,
                            selector=selector,
                            text=text.strip()[:50] if text else '',
                            file_path=str(file_path),
                            line_number=line_num,
                            attributes=attrs
                        )
                        self.ui_elements.append(element)

        except Exception as e:
            print(f"  ‚ö† Error analyzing {file_path}: {e}")

    def _extract_attributes(self, html_tag: str) -> Dict[str, str]:
        """Extract attributes from HTML tag"""
        attrs = {}

        # Extract id
        id_match = re.search(r'id=["\']([^"\']+)["\']', html_tag)
        if id_match:
            attrs['id'] = id_match.group(1)

        # Extract class
        class_match = re.search(r'class(?:Name)?=["\']([^"\']+)["\']', html_tag)
        if class_match:
            attrs['class'] = class_match.group(1)

        # Extract name
        name_match = re.search(r'name=["\']([^"\']+)["\']', html_tag)
        if name_match:
            attrs['name'] = name_match.group(1)

        # Extract type
        type_match = re.search(r'type=["\']([^"\']+)["\']', html_tag)
        if type_match:
            attrs['type'] = type_match.group(1)

        # Extract value
        value_match = re.search(r'value=["\']([^"\']+)["\']', html_tag)
        if value_match:
            attrs['value'] = value_match.group(1)

        # Extract data-testid
        testid_match = re.search(r'data-testid=["\']([^"\']+)["\']', html_tag)
        if testid_match:
            attrs['data-testid'] = testid_match.group(1)

        return attrs

    def _build_selector(self, attrs: Dict[str, str], element_type: str) -> str:
        """Build a CSS selector from attributes"""
        # Prefer id
        if 'id' in attrs:
            return f"#{attrs['id']}"

        # Then data-testid
        if 'data-testid' in attrs:
            return f"[data-testid='{attrs['data-testid']}']"

        # Then name
        if 'name' in attrs:
            return f"[name='{attrs['name']}']"

        # Then class
        if 'class' in attrs:
            first_class = attrs['class'].split()[0]
            return f".{first_class}"

        # Fallback to element type
        return element_type

    def get_coverage_report(self, tested_selectors: Set[str]) -> Dict[str, Any]:
        """Generate coverage report comparing code vs tests"""
        total = len(self.ui_elements)
        if total == 0:
            return {
                "total_elements": 0,
                "tested_elements": 0,
                "untested_elements": 0,
                "coverage_percentage": 100,
                "untested": []
            }

        tested = []
        untested = []

        for element in self.ui_elements:
            if element.selector in tested_selectors or element.text in tested_selectors:
                tested.append(element)
            else:
                untested.append(element)

        return {
            "total_elements": total,
            "tested_elements": len(tested),
            "untested_elements": len(untested),
            "coverage_percentage": (len(tested) / total * 100) if total > 0 else 100,
            "untested": [
                {
                    "type": e.element_type,
                    "selector": e.selector,
                    "text": e.text,
                    "file": e.file_path,
                    "line": e.line_number
                }
                for e in untested
            ]
        }


class WebCrawler:
    """Automatically discover and test all pages and interactive elements"""

    def __init__(self, base_url: str, max_depth: int = 3, max_pages: int = 100):
        self.base_url = base_url
        self.base_domain = urlparse(base_url).netloc
        self.max_depth = max_depth
        self.max_pages = max_pages

        self.visited_urls: Set[str] = set()
        self.discovered_routes: List[Dict[str, Any]] = []
        self.interactive_states: List[Dict[str, Any]] = []

    def normalize_url(self, url: str) -> str:
        """Normalize URL for deduplication"""
        parsed = urlparse(url)
        # Remove fragments and trailing slashes
        normalized = f"{parsed.scheme}://{parsed.netloc}{parsed.path.rstrip('/')}"
        if parsed.query:
            normalized += f"?{parsed.query}"
        return normalized

    def is_same_domain(self, url: str) -> bool:
        """Check if URL is on the same domain"""
        return urlparse(url).netloc == self.base_domain

    def should_skip_url(self, url: str) -> bool:
        """Check if URL should be skipped"""
        # Skip common patterns
        skip_patterns = [
            r'\.pdf$', r'\.zip$', r'\.exe$', r'\.dmg$',
            r'\.jpg$', r'\.png$', r'\.gif$', r'\.svg$',
            r'/logout', r'/signout', r'/delete',
            r'mailto:', r'tel:', r'javascript:',
        ]
        return any(re.search(pattern, url, re.I) for pattern in skip_patterns)

    async def discover_links(self, page) -> List[str]:
        """Find all links on the current page"""
        links = await page.evaluate("""() => {
            const links = Array.from(document.querySelectorAll('a[href]'));
            return links.map(link => link.href).filter(href => href && !href.startsWith('#'));
        }""")

        # Filter and normalize links
        valid_links = []
        for link in links:
            if self.is_same_domain(link) and not self.should_skip_url(link):
                normalized = self.normalize_url(link)
                if normalized not in self.visited_urls:
                    valid_links.append(normalized)

        return valid_links

    async def discover_interactive_elements(self, page) -> List[Dict[str, Any]]:
        """Find ALL interactive elements including buttons, checkboxes, radios, selects, tabs, accordions, etc."""
        elements = await page.evaluate("""() => {
            const results = [];

            // Helper to check visibility
            const isVisible = (el) => {
                const rect = el.getBoundingClientRect();
                const style = window.getComputedStyle(el);
                return rect.width > 0 && rect.height > 0 &&
                       style.display !== 'none' &&
                       style.visibility !== 'hidden' &&
                       style.opacity !== '0';
            };

            // Helper to get unique selector
            const getSelector = (el, type, index) => {
                if (el.id) return `#${el.id}`;
                if (el.getAttribute('data-testid')) return `[data-testid="${el.getAttribute('data-testid')}"]`;
                if (el.name) return `[name="${el.name}"]`;
                if (el.className && typeof el.className === 'string') {
                    const classes = el.className.split(' ').filter(c => c.length > 0);
                    if (classes.length > 0) return `.${classes[0]}`;
                }
                return `${type}:nth-of-type(${index + 1})`;
            };

            // 1. Buttons and clickable elements
            const buttons = Array.from(document.querySelectorAll(
                'button, [role="button"], [onclick], input[type="submit"], input[type="button"], .btn, [class*="button"], [class*="Button"]'
            ));
            buttons.forEach((el, i) => {
                if (isVisible(el) && !el.disabled) {
                    results.push({
                        selector: getSelector(el, 'button', i),
                        text: el.textContent?.trim() || el.value || el.getAttribute('aria-label') || 'Button',
                        type: 'button',
                        action: 'click',
                        priority: 1
                    });
                }
            });

            // 2. Links
            const links = Array.from(document.querySelectorAll('a[href]'));
            links.forEach((el, i) => {
                if (isVisible(el) && el.href && !el.href.startsWith('#') && !el.href.includes('javascript:')) {
                    results.push({
                        selector: getSelector(el, 'a', i),
                        text: el.textContent?.trim() || el.getAttribute('aria-label') || 'Link',
                        type: 'link',
                        action: 'click',
                        priority: 2
                    });
                }
            });

            // 3. Checkboxes
            const checkboxes = Array.from(document.querySelectorAll('input[type="checkbox"]'));
            checkboxes.forEach((el, i) => {
                if (isVisible(el) && !el.disabled) {
                    results.push({
                        selector: getSelector(el, 'input[type="checkbox"]', i),
                        text: el.labels?.[0]?.textContent?.trim() || el.getAttribute('aria-label') || 'Checkbox',
                        type: 'checkbox',
                        action: 'check',
                        checked: el.checked,
                        priority: 1
                    });
                }
            });

            // 4. Radio buttons
            const radios = Array.from(document.querySelectorAll('input[type="radio"]'));
            radios.forEach((el, i) => {
                if (isVisible(el) && !el.disabled) {
                    results.push({
                        selector: getSelector(el, 'input[type="radio"]', i),
                        text: el.labels?.[0]?.textContent?.trim() || el.getAttribute('aria-label') || 'Radio',
                        type: 'radio',
                        action: 'check',
                        priority: 1
                    });
                }
            });

            // 5. Select dropdowns
            const selects = Array.from(document.querySelectorAll('select'));
            selects.forEach((el, i) => {
                if (isVisible(el) && !el.disabled && el.options.length > 0) {
                    results.push({
                        selector: getSelector(el, 'select', i),
                        text: el.labels?.[0]?.textContent?.trim() || el.getAttribute('aria-label') || 'Dropdown',
                        type: 'select',
                        action: 'select',
                        options: Array.from(el.options).slice(0, 3).map(opt => opt.value).filter(v => v),
                        priority: 1
                    });
                }
            });

            // 6. Text inputs (for filling)
            const inputs = Array.from(document.querySelectorAll('input[type="text"], input[type="email"], input[type="password"], input[type="search"], input[type="tel"], input[type="url"], input:not([type]), textarea'));
            inputs.forEach((el, i) => {
                if (isVisible(el) && !el.disabled && !el.readOnly) {
                    results.push({
                        selector: getSelector(el, el.tagName.toLowerCase(), i),
                        text: el.labels?.[0]?.textContent?.trim() || el.placeholder || el.getAttribute('aria-label') || 'Input',
                        type: 'input',
                        action: 'fill',
                        inputType: el.type || 'text',
                        priority: 2
                    });
                }
            });

            // 7. Tabs (role="tab" or common tab patterns)
            const tabs = Array.from(document.querySelectorAll('[role="tab"], .tab, [class*="tab"]:not([class*="table"])'));
            tabs.forEach((el, i) => {
                if (isVisible(el)) {
                    results.push({
                        selector: getSelector(el, '[role="tab"]', i),
                        text: el.textContent?.trim() || el.getAttribute('aria-label') || 'Tab',
                        type: 'tab',
                        action: 'click',
                        priority: 1
                    });
                }
            });

            // 8. Accordions (details/summary or role="button" with aria-expanded)
            const accordions = Array.from(document.querySelectorAll('details > summary, [aria-expanded], .accordion, [class*="accordion"]'));
            accordions.forEach((el, i) => {
                if (isVisible(el)) {
                    results.push({
                        selector: getSelector(el, 'summary', i),
                        text: el.textContent?.trim()?.substring(0, 50) || 'Accordion',
                        type: 'accordion',
                        action: 'click',
                        expanded: el.getAttribute('aria-expanded') === 'true',
                        priority: 1
                    });
                }
            });

            // 9. Toggle switches
            const toggles = Array.from(document.querySelectorAll('[role="switch"], .toggle, [class*="toggle"], [class*="switch"]'));
            toggles.forEach((el, i) => {
                if (isVisible(el)) {
                    results.push({
                        selector: getSelector(el, '[role="switch"]', i),
                        text: el.textContent?.trim() || el.getAttribute('aria-label') || 'Toggle',
                        type: 'toggle',
                        action: 'click',
                        priority: 1
                    });
                }
            });

            // 10. Modal/Dialog triggers (buttons that open modals)
            const modalTriggers = Array.from(document.querySelectorAll('[data-toggle="modal"], [data-bs-toggle="modal"], [aria-haspopup="dialog"], [class*="modal"][class*="trigger"]'));
            modalTriggers.forEach((el, i) => {
                if (isVisible(el)) {
                    results.push({
                        selector: getSelector(el, '[data-toggle]', i),
                        text: el.textContent?.trim() || el.getAttribute('aria-label') || 'Modal Trigger',
                        type: 'modal-trigger',
                        action: 'click',
                        priority: 1
                    });
                }
            });

            // 11. Menu items
            const menuItems = Array.from(document.querySelectorAll('[role="menuitem"], .menu-item, [class*="menu-item"]'));
            menuItems.forEach((el, i) => {
                if (isVisible(el)) {
                    results.push({
                        selector: getSelector(el, '[role="menuitem"]', i),
                        text: el.textContent?.trim() || 'Menu Item',
                        type: 'menu-item',
                        action: 'click',
                        priority: 2
                    });
                }
            });

            return results;
        }""")

        return elements

    async def discover_forms(self, page) -> List[Dict[str, Any]]:
        """Find all forms and their inputs"""
        forms = await page.evaluate("""() => {
            const forms = Array.from(document.querySelectorAll('form'));

            return forms.map((form, formIndex) => {
                const inputs = Array.from(form.querySelectorAll('input, select, textarea')).map((input, inputIndex) => {
                    return {
                        selector: input.id ? `#${input.id}` : input.name ? `[name="${input.name}"]` : `input:nth-of-type(${inputIndex + 1})`,
                        type: input.type || input.tagName.toLowerCase(),
                        name: input.name || '',
                        placeholder: input.placeholder || '',
                        required: input.required || false
                    };
                });

                return {
                    selector: form.id ? `#${form.id}` : `form:nth-of-type(${formIndex + 1})`,
                    action: form.action || '',
                    method: form.method || 'get',
                    inputs: inputs
                };
            });
        }""")

        return forms

    def generate_test_data(self, input_info: Dict[str, Any]) -> str:
        """Generate appropriate test data for form inputs"""
        input_type = input_info.get('type', 'text').lower()
        name = input_info.get('name', '').lower()
        placeholder = input_info.get('placeholder', '').lower()

        # Email detection
        if input_type == 'email' or 'email' in name or 'email' in placeholder:
            return 'test@example.com'

        # Password detection
        if input_type == 'password' or 'password' in name or 'pass' in name:
            return 'TestPassword123!'

        # URL detection
        if input_type == 'url' or 'url' in name or 'website' in name:
            return 'https://example.com'

        # Number detection
        if input_type == 'number' or 'age' in name or 'amount' in name:
            return '25'

        # Tel detection
        if input_type == 'tel' or 'phone' in name or 'tel' in name:
            return '555-0123'

        # Date detection
        if input_type == 'date':
            return '2024-01-01'

        # Name detection
        if 'name' in name or 'name' in placeholder:
            if 'first' in name or 'first' in placeholder:
                return 'John'
            elif 'last' in name or 'last' in placeholder:
                return 'Doe'
            else:
                return 'John Doe'

        # Search detection
        if input_type == 'search' or 'search' in name or 'search' in placeholder:
            return 'test query'

        # Default text
        return 'Test Input'

    async def crawl_page(self, page, url: str, depth: int = 0):
        """Recursively crawl a page and discover all interactive elements"""
        if depth > self.max_depth or len(self.visited_urls) >= self.max_pages:
            return

        if url in self.visited_urls:
            return

        print(f"{'  ' * depth}üîç Crawling: {url} (depth: {depth})")

        try:
            await page.goto(url, wait_until="networkidle", timeout=30000)
            await asyncio.sleep(1)

            self.visited_urls.add(url)

            # Add base route
            route_name = self._url_to_name(url)
            self.discovered_routes.append({
                "route": url.replace(self.base_url, ""),
                "name": route_name,
                "description": f"Auto-discovered: {url}",
                "depth": depth
            })

            # Discover ALL interactive elements
            elements = await self.discover_interactive_elements(page)
            print(f"{'  ' * depth}  Found {len(elements)} interactive elements")

            # Group by priority (priority 1 = most important)
            elements.sort(key=lambda x: x.get('priority', 3))

            # Test ALL elements (no limit - we want 100% coverage!)
            for i, elem in enumerate(elements):
                elem_name = f"{route_name}_{elem['type']}_{i}_{self._sanitize_name(elem['text'])}"
                actions = []

                # Build appropriate action based on element type
                if elem['action'] == 'click':
                    actions.append({"type": "click", "selector": elem['selector']})
                elif elem['action'] == 'check':
                    # For checkboxes/radios, toggle their state
                    if elem['type'] == 'checkbox' and not elem.get('checked'):
                        actions.append({"type": "check", "selector": elem['selector']})
                    elif elem['type'] == 'radio':
                        actions.append({"type": "check", "selector": elem['selector']})
                elif elem['action'] == 'select' and elem.get('options'):
                    # Try first available option
                    actions.append({"type": "select", "selector": elem['selector'], "value": elem['options'][0]})
                elif elem['action'] == 'fill':
                    # Generate test data based on input type
                    test_value = self.generate_test_data({'type': elem.get('inputType', 'text'), 'name': elem['text'].lower()})
                    actions.append({"type": "fill", "selector": elem['selector'], "value": test_value})

                if actions:
                    actions.append({"type": "wait", "ms": 500})
                    self.interactive_states.append({
                        "route": url.replace(self.base_url, ""),
                        "name": elem_name,
                        "description": f"After {elem['action']} on {elem['type']} '{elem['text']}'",
                        "actions": actions
                    })

            # Discover and test forms
            forms = await self.discover_forms(page)
            print(f"{'  ' * depth}  Found {len(forms)} forms")

            for i, form in enumerate(forms):
                if len(form['inputs']) > 0:
                    form_name = f"{route_name}_form_{i}"
                    actions = []

                    for input_info in form['inputs']:
                        if input_info['type'] not in ['submit', 'button', 'hidden']:
                            test_value = self.generate_test_data(input_info)
                            actions.append({
                                "type": "fill",
                                "selector": input_info['selector'],
                                "value": test_value
                            })

                    if actions:
                        actions.append({"type": "wait", "ms": 500})
                        self.interactive_states.append({
                            "route": url.replace(self.base_url, ""),
                            "name": f"{form_name}_filled",
                            "description": f"Form filled with test data",
                            "actions": actions
                        })

            # Discover links for recursive crawling
            if depth < self.max_depth:
                links = await self.discover_links(page)
                print(f"{'  ' * depth}  Found {len(links)} new links to explore")

                for link in links[:5]:  # Limit breadth
                    if len(self.visited_urls) < self.max_pages:
                        await self.crawl_page(page, link, depth + 1)

        except Exception as e:
            print(f"{'  ' * depth}‚úó Error crawling {url}: {e}")

    def _url_to_name(self, url: str) -> str:
        """Convert URL to a valid name"""
        path = urlparse(url).path.strip('/')
        if not path:
            return 'home'
        return self._sanitize_name(path.replace('/', '_'))

    def _sanitize_name(self, text: str) -> str:
        """Sanitize text for use as a name"""
        # Remove special characters, limit length
        name = re.sub(r'[^a-zA-Z0-9_-]', '_', text)
        name = re.sub(r'_+', '_', name).strip('_')
        return name[:50].lower()

    def get_all_routes(self) -> List[Dict[str, Any]]:
        """Get all discovered routes including interactive states"""
        return self.discovered_routes + self.interactive_states


class WebAppTester:
    def __init__(
        self,
        base_url: str,
        output_dir: str = "test_results",
        baseline_dir: Optional[str] = None,
        screenshot_format: str = "png",
        enable_video: bool = False,
        enable_network_logs: bool = False,
        enable_coverage: bool = False,
        device: Optional[str] = None,
        network: Optional[str] = None,
        max_parallel: int = 1,
        auto_discover: bool = False,
        max_depth: int = 3,
        max_pages: int = 100,
        source_dir: Optional[str] = None,
        enable_ui_coverage: bool = False,
        before_after_screenshots: bool = False,
    ):
        self.base_url = base_url
        self.output_dir = Path(output_dir)
        self.screenshots_dir = self.output_dir / "screenshots"
        self.screenshots_dir.mkdir(parents=True, exist_ok=True)

        self.baseline_dir = Path(baseline_dir) if baseline_dir else None
        if self.baseline_dir:
            self.baseline_dir.mkdir(parents=True, exist_ok=True)
            self.diff_dir = self.output_dir / "diffs"
            self.diff_dir.mkdir(parents=True, exist_ok=True)

        self.screenshot_format = screenshot_format.lower()
        self.enable_video = enable_video
        self.enable_network_logs = enable_network_logs
        self.enable_coverage = enable_coverage
        self.max_parallel = max(1, max_parallel)

        self.auto_discover = auto_discover
        self.max_depth = max_depth
        self.max_pages = max_pages

        # UI Coverage validation
        self.source_dir = source_dir
        self.enable_ui_coverage = enable_ui_coverage
        self.before_after_screenshots = before_after_screenshots
        self.tested_selectors: Set[str] = set()
        self.code_analyzer: Optional[CodeAnalyzer] = None

        # Store screenshot paths for post-test review
        self.screenshot_paths: List[Dict[str, str]] = []

        self.device_config = DEVICE_PRESETS.get(device) if device else None
        self.network_config = NETWORK_PRESETS.get(network) if network else None

        self.test_results: List[Dict[str, Any]] = []
        self.network_logs: List[Dict[str, Any]] = []
        self.coverage_data: Dict[str, Any] = {}
        self.ui_coverage_report: Dict[str, Any] = {}

        if self.enable_video:
            self.videos_dir = self.output_dir / "videos"
            self.videos_dir.mkdir(parents=True, exist_ok=True)

        # Initialize code analyzer if source directory provided
        if self.source_dir and self.enable_ui_coverage:
            self.code_analyzer = CodeAnalyzer(self.source_dir)
            self.code_analyzer.analyze()

    def compare_images(self, img1_path: Path, img2_path: Path) -> Dict[str, Any]:
        """Compare two images and generate a diff image."""
        try:
            img1 = Image.open(img1_path).convert('RGB')
            img2 = Image.open(img2_path).convert('RGB')

            # Resize if dimensions don't match
            if img1.size != img2.size:
                img2 = img2.resize(img1.size)

            # Calculate difference
            diff = ImageChops.difference(img1, img2)

            # Calculate similarity score
            diff_data = diff.getdata()
            total_pixels = len(diff_data)
            different_pixels = sum(1 for pixel in diff_data if pixel != (0, 0, 0))
            similarity = 1 - (different_pixels / total_pixels)

            # Generate visual diff with red highlights
            diff_visual = img2.copy()
            draw = ImageDraw.Draw(diff_visual, 'RGBA')

            for x in range(diff.width):
                for y in range(diff.height):
                    if diff.getpixel((x, y)) != (0, 0, 0):
                        draw.point((x, y), fill=(255, 0, 0, 128))

            return {
                "match": similarity > 0.99,
                "similarity": similarity,
                "different_pixels": different_pixels,
                "total_pixels": total_pixels,
                "diff_image": diff_visual,
            }

        except Exception as e:
            return {"error": str(e), "match": False}

    async def take_screenshot(
        self,
        page,
        name: str,
        description: str = "",
        format_override: Optional[str] = None,
    ):
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        fmt = format_override or self.screenshot_format
        filename = f"{timestamp}_{name}.{fmt}"
        filepath = self.screenshots_dir / filename

        try:
            # Take screenshot with specified format
            screenshot_options = {"path": str(filepath), "full_page": True}
            if fmt == "jpeg":
                screenshot_options["quality"] = 85

            await page.screenshot(**screenshot_options)

            result = {
                "name": name,
                "description": description,
                "url": page.url,
                "screenshot": str(filepath),
                "timestamp": timestamp,
                "status": "success",
                "format": fmt,
            }

            # Store screenshot path for later review by Claude
            self.screenshot_paths.append({
                "name": name,
                "description": description,
                "path": str(filepath),
                "url": page.url
            })

            # Visual regression testing
            if self.baseline_dir:
                baseline_file = self.baseline_dir / f"{name}.{fmt}"
                if baseline_file.exists():
                    comparison = self.compare_images(baseline_file, filepath)
                    result["visual_regression"] = {
                        "baseline": str(baseline_file),
                        "match": comparison.get("match", False),
                        "similarity": comparison.get("similarity", 0),
                        "different_pixels": comparison.get("different_pixels", 0),
                    }

                    # Save diff image if there are differences
                    if not comparison.get("match") and "diff_image" in comparison:
                        diff_path = self.diff_dir / f"{timestamp}_{name}_diff.{fmt}"
                        comparison["diff_image"].save(diff_path)
                        result["visual_regression"]["diff_image"] = str(diff_path)
                        print(f"‚ö† Visual difference detected: {name} ({comparison['similarity']:.2%} similar)")
                else:
                    # Create baseline if it doesn't exist
                    Image.open(filepath).save(baseline_file)
                    result["visual_regression"] = {"baseline_created": True}
                    print(f"üì∏ Baseline created: {name}")

            self.test_results.append(result)
            print(f"‚úì Screenshot captured: {name}")
            return result

        except Exception as e:
            error_result = {
                "name": name,
                "description": description,
                "url": page.url,
                "screenshot": None,
                "timestamp": timestamp,
                "status": "error",
                "error": str(e),
            }
            self.test_results.append(error_result)
            print(f"‚úó Error capturing {name}: {e}")
            return error_result

    async def perform_actions(self, page, actions: List[Dict[str, Any]], test_name: str = ""):
        """Perform interactive actions on the page with before/after screenshots."""
        for i, action in enumerate(actions):
            action_type = action.get("type")

            try:
                # Take "before" screenshot if enabled
                if self.before_after_screenshots and action_type in ["click", "fill", "select", "check", "uncheck"]:
                    selector = action.get("selector", "")
                    before_name = f"{test_name}_action{i}_before" if test_name else f"action{i}_before"
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    fmt = self.screenshot_format
                    before_path = self.screenshots_dir / f"{timestamp}_{before_name}.{fmt}"

                    screenshot_options = {"path": str(before_path), "full_page": True}
                    if fmt == "jpeg":
                        screenshot_options["quality"] = 85
                    await page.screenshot(**screenshot_options)
                    print(f"  üì∏ Before screenshot: {before_name}")

                if action_type == "click":
                    selector = action.get("selector")
                    # Track tested selector
                    self.tested_selectors.add(selector)
                    await page.click(selector, timeout=5000)
                    print(f"  ‚Üí Clicked: {selector}")

                elif action_type == "check":
                    selector = action.get("selector")
                    # Track tested selector
                    self.tested_selectors.add(selector)
                    await page.check(selector, timeout=5000)
                    print(f"  ‚Üí Checked: {selector}")

                elif action_type == "uncheck":
                    selector = action.get("selector")
                    # Track tested selector
                    self.tested_selectors.add(selector)
                    await page.uncheck(selector, timeout=5000)
                    print(f"  ‚Üí Unchecked: {selector}")

                elif action_type == "fill":
                    selector = action.get("selector")
                    value = action.get("value", "")
                    # Track tested selector
                    self.tested_selectors.add(selector)
                    await page.fill(selector, value, timeout=5000)
                    print(f"  ‚Üí Filled: {selector}")

                elif action_type == "select":
                    selector = action.get("selector")
                    value = action.get("value")
                    # Track tested selector
                    self.tested_selectors.add(selector)
                    await page.select_option(selector, value, timeout=5000)
                    print(f"  ‚Üí Selected: {selector} = {value}")

                elif action_type == "scroll":
                    x = action.get("x", 0)
                    y = action.get("y", 0)
                    await page.evaluate(f"window.scrollTo({x}, {y})")
                    print(f"  ‚Üí Scrolled to: ({x}, {y})")

                elif action_type == "scroll_to":
                    selector = action.get("selector")
                    await page.locator(selector).scroll_into_view_if_needed()
                    print(f"  ‚Üí Scrolled to: {selector}")

                elif action_type == "hover":
                    selector = action.get("selector")
                    await page.hover(selector, timeout=5000)
                    print(f"  ‚Üí Hovered: {selector}")

                elif action_type == "wait":
                    ms = action.get("ms", 1000)
                    await asyncio.sleep(ms / 1000)
                    print(f"  ‚Üí Waited: {ms}ms")

                elif action_type == "press":
                    selector = action.get("selector")
                    key = action.get("key")
                    await page.press(selector, key, timeout=5000)
                    print(f"  ‚Üí Pressed: {key} on {selector}")

                # Take "after" screenshot if enabled
                if self.before_after_screenshots and action_type in ["click", "fill", "select", "check", "uncheck"]:
                    await asyncio.sleep(0.5)  # Brief wait for UI to update
                    after_name = f"{test_name}_action{i}_after" if test_name else f"action{i}_after"
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    fmt = self.screenshot_format
                    after_path = self.screenshots_dir / f"{timestamp}_{after_name}.{fmt}"

                    screenshot_options = {"path": str(after_path), "full_page": True}
                    if fmt == "jpeg":
                        screenshot_options["quality"] = 85
                    await page.screenshot(**screenshot_options)
                    print(f"  üì∏ After screenshot: {after_name}")

            except Exception as e:
                print(f"  ‚úó Action failed ({action_type}): {e}")

    async def collect_coverage(self, page) -> Dict[str, Any]:
        """Collect JavaScript code coverage from the page"""
        try:
            coverage = await page.evaluate("""() => {
                if (window.__coverage__) {
                    return window.__coverage__;
                }
                return null;
            }""")
            return coverage or {}
        except Exception as e:
            print(f"  ‚ö† Coverage collection failed: {e}")
            return {}

    async def test_route(
        self,
        page,
        route: str,
        name: str,
        description: str = "",
        wait_for: Optional[str] = None,
        actions: Optional[List[Dict[str, Any]]] = None,
    ):
        # Handle full URLs vs relative paths
        if route.startswith('http'):
            url = route
        else:
            url = f"{self.base_url}{route}"

        print(f"Testing: {url}")
        if actions:
            print(f"  üìã {len(actions)} action(s) to perform: {description}")

        try:
            await page.goto(url, wait_until="networkidle", timeout=30000)

            if wait_for:
                await page.wait_for_selector(wait_for, timeout=10000)

            # Perform interactive actions if specified
            if actions:
                await self.perform_actions(page, actions, test_name=name)

            await asyncio.sleep(1)

            # Collect coverage if enabled
            if self.enable_coverage:
                coverage = await self.collect_coverage(page)
                if coverage:
                    self.coverage_data[name] = coverage

            return await self.take_screenshot(page, name, description)

        except Exception as e:
            print(f"‚úó Error navigating to {url}: {e}")
            error_result = {
                "name": name,
                "description": description,
                "url": url,
                "screenshot": None,
                "timestamp": datetime.now().strftime("%Y%m%d_%H%M%S"),
                "status": "error",
                "error": str(e),
            }
            self.test_results.append(error_result)
            return error_result

    async def test_route_worker(self, page, route_info: Dict[str, Any]):
        """Worker function for parallel execution."""
        return await self.test_route(
            page,
            route_info["route"],
            route_info["name"],
            route_info.get("description", ""),
            route_info.get("wait_for"),
            route_info.get("actions"),
        )

    async def run_tests(self, routes: List[Dict[str, Any]]):
        async with async_playwright() as p:
            # Browser launch options
            launch_options = {"headless": True}

            browser = await p.chromium.launch(**launch_options)

            # Context options
            context_options = {}

            if self.device_config:
                context_options["viewport"] = {
                    "width": self.device_config["width"],
                    "height": self.device_config["height"],
                }
                context_options["device_scale_factor"] = self.device_config["device_scale_factor"]
                context_options["is_mobile"] = self.device_config["is_mobile"]
                context_options["has_touch"] = self.device_config["has_touch"]
                if "user_agent" in self.device_config:
                    context_options["user_agent"] = self.device_config["user_agent"]
            else:
                context_options["viewport"] = {"width": 1920, "height": 1080}

            # Video recording
            if self.enable_video:
                context_options["record_video_dir"] = str(self.videos_dir)
                context_options["record_video_size"] = context_options["viewport"]

            context = await browser.new_context(**context_options)

            # Network emulation
            if self.network_config:
                if self.network_config.get("offline"):
                    await context.set_offline(True)

            # Auto-discovery mode
            if self.auto_discover:
                print(f"\nü§ñ AUTO-DISCOVERY MODE ENABLED")
                print(f"Max depth: {self.max_depth}, Max pages: {self.max_pages}\n")

                crawler = WebCrawler(self.base_url, self.max_depth, self.max_pages)
                discovery_page = await context.new_page()

                await crawler.crawl_page(discovery_page, self.base_url, depth=0)
                await discovery_page.close()

                discovered_routes = crawler.get_all_routes()
                print(f"\n‚úì Discovery complete! Found {len(discovered_routes)} routes/states\n")

                # Merge with provided routes (provided routes take precedence)
                route_names = {r['name'] for r in routes}
                for discovered in discovered_routes:
                    if discovered['name'] not in route_names:
                        routes.append(discovered)

            print(f"\nüöÄ Starting tests for: {self.base_url}")
            print(f"Testing {len(routes)} routes...")
            if self.device_config:
                print(f"Device: {list(DEVICE_PRESETS.keys())[list(DEVICE_PRESETS.values()).index(self.device_config)]}")
            if self.network_config:
                print(f"Network: {list(NETWORK_PRESETS.keys())[list(NETWORK_PRESETS.values()).index(self.network_config)]}")
            print(f"Parallel workers: {self.max_parallel}\n")

            # Network logging
            if self.enable_network_logs:
                async def log_request(request):
                    self.network_logs.append({
                        "type": "request",
                        "url": request.url,
                        "method": request.method,
                        "resource_type": request.resource_type,
                        "timestamp": datetime.now().isoformat(),
                    })

                async def log_response(response):
                    self.network_logs.append({
                        "type": "response",
                        "url": response.url,
                        "status": response.status,
                        "ok": response.ok,
                        "timestamp": datetime.now().isoformat(),
                    })

                async def log_request_failed(request):
                    self.network_logs.append({
                        "type": "request_failed",
                        "url": request.url,
                        "failure": request.failure,
                        "timestamp": datetime.now().isoformat(),
                    })

            # Parallel execution
            if self.max_parallel > 1:
                # Create multiple pages for parallel testing
                semaphore = asyncio.Semaphore(self.max_parallel)

                async def test_with_semaphore(route_info):
                    async with semaphore:
                        page = await context.new_page()

                        if self.enable_network_logs:
                            page.on("request", log_request)
                            page.on("response", log_response)
                            page.on("requestfailed", log_request_failed)

                        try:
                            result = await self.test_route_worker(page, route_info)
                            return result
                        finally:
                            await page.close()

                # Run tests in parallel
                await asyncio.gather(*[test_with_semaphore(route) for route in routes])
            else:
                # Sequential execution with single page
                page = await context.new_page()

                if self.enable_network_logs:
                    page.on("request", log_request)
                    page.on("response", log_response)
                    page.on("requestfailed", log_request_failed)

                for route_info in routes:
                    await self.test_route_worker(page, route_info)

                await page.close()

            await context.close()
            await browser.close()

        # Generate UI coverage report if enabled
        if self.code_analyzer:
            self.ui_coverage_report = self.code_analyzer.get_coverage_report(self.tested_selectors)
            print(f"\nüìä UI Coverage Report:")
            print(f"  Total UI elements in code: {self.ui_coverage_report['total_elements']}")
            print(f"  Tested elements: {self.ui_coverage_report['tested_elements']}")
            print(f"  Untested elements: {self.ui_coverage_report['untested_elements']}")
            print(f"  Coverage: {self.ui_coverage_report['coverage_percentage']:.1f}%")
            if self.ui_coverage_report['untested']:
                print(f"\n‚ö† Untested UI elements found:")
                for elem in self.ui_coverage_report['untested'][:10]:  # Show first 10
                    print(f"    - {elem['type']} '{elem['text']}' at {elem['file']}:{elem['line']}")

        # Save screenshot paths for Claude to review
        screenshots_review_file = self.output_dir / "screenshots_for_review.json"
        with open(screenshots_review_file, 'w') as f:
            json.dump(self.screenshot_paths, f, indent=2)

        print(f"\nüì∏ Saved {len(self.screenshot_paths)} screenshots for review")
        print(f"   Review file: {screenshots_review_file}")
        print(f"   Claude will review these screenshots as a picky UI designer")

        self.generate_report()
        return self.test_results

    def generate_report(self):
        # JSON report with network logs and coverage
        report_data = {
            "base_url": self.base_url,
            "test_date": datetime.now().isoformat(),
            "total_tests": len(self.test_results),
            "successful": len([r for r in self.test_results if r["status"] == "success"]),
            "failed": len([r for r in self.test_results if r["status"] == "error"]),
            "results": self.test_results,
        }

        if self.enable_network_logs:
            report_data["network_logs"] = self.network_logs
            report_data["network_summary"] = {
                "total_requests": len([l for l in self.network_logs if l["type"] == "request"]),
                "failed_requests": len([l for l in self.network_logs if l["type"] == "request_failed"]),
            }

        if self.enable_coverage and self.coverage_data:
            report_data["coverage"] = self.coverage_data

            # Save separate coverage file
            coverage_path = self.output_dir / "coverage.json"
            with open(coverage_path, "w") as f:
                json.dump(self.coverage_data, f, indent=2)
            print(f"  - Coverage: {coverage_path}")

        # Add UI coverage report
        if self.ui_coverage_report:
            report_data["ui_coverage"] = self.ui_coverage_report

            # Save separate UI coverage file
            ui_coverage_path = self.output_dir / "ui_coverage.json"
            with open(ui_coverage_path, "w") as f:
                json.dump(self.ui_coverage_report, f, indent=2)
            print(f"  - UI Coverage: {ui_coverage_path}")

        json_path = self.output_dir / "test_report.json"
        with open(json_path, "w") as f:
            json.dump(report_data, f, indent=2)

        # HTML report
        html_path = self.output_dir / "test_report.html"
        html_content = self._generate_html_report()
        with open(html_path, "w") as f:
            f.write(html_content)

        print(f"\n‚úì Reports generated:")
        print(f"  - JSON: {json_path}")
        print(f"  - HTML: {html_path}")

        if self.enable_video:
            print(f"  - Videos: {self.videos_dir}")

    def _generate_html_report(self) -> str:
        successful = len([r for r in self.test_results if r["status"] == "success"])
        failed = len([r for r in self.test_results if r["status"] == "error"])

        # Visual regression summary
        visual_regression_html = ""
        if self.baseline_dir:
            with_diff = len([r for r in self.test_results if r.get("visual_regression", {}).get("match") == False])
            visual_regression_html = f"""
            <div class="summary-card regression">
                <h2>{with_diff}</h2>
                <p>Visual Differences</p>
            </div>
            """

        # Network logs summary
        network_html = ""
        if self.enable_network_logs:
            failed_requests = len([l for l in self.network_logs if l["type"] == "request_failed"])
            network_html = f"""
            <div class="summary-card network">
                <h2>{len(self.network_logs)}</h2>
                <p>Network Events</p>
            </div>
            <div class="summary-card network-failed">
                <h2>{failed_requests}</h2>
                <p>Failed Requests</p>
            </div>
            """

        # Coverage summary
        coverage_html = ""
        if self.enable_coverage and self.coverage_data:
            coverage_html = f"""
            <div class="summary-card coverage">
                <h2>{len(self.coverage_data)}</h2>
                <p>Pages with Coverage</p>
            </div>
            """

        # UI Coverage summary
        ui_coverage_html = ""
        if self.ui_coverage_report:
            ui_cov_pct = self.ui_coverage_report.get('coverage_percentage', 0)
            untested_count = self.ui_coverage_report.get('untested_elements', 0)
            ui_coverage_html = f"""
            <div class="summary-card ui-coverage">
                <h2>{ui_cov_pct:.1f}%</h2>
                <p>UI Coverage</p>
            </div>
            <div class="summary-card ui-untested">
                <h2>{untested_count}</h2>
                <p>Untested Elements</p>
            </div>
            """

        results_html = ""
        for result in self.test_results:
            status_class = "success" if result["status"] == "success" else "error"
            status_icon = "‚úì" if result["status"] == "success" else "‚úó"

            screenshot_html = ""
            if result.get("screenshot"):
                rel_path = Path(result["screenshot"]).relative_to(self.output_dir)
                screenshot_html = f'<img src="{rel_path}" alt="{result["name"]}">'

            error_html = ""
            if result.get("error"):
                error_html = f'<div class="error-msg">Error: {result["error"]}</div>'

            # Visual regression info
            vr_html = ""
            if result.get("visual_regression"):
                vr = result["visual_regression"]
                if vr.get("baseline_created"):
                    vr_html = '<div class="vr-info baseline">üì∏ Baseline created</div>'
                elif vr.get("match"):
                    vr_html = f'<div class="vr-info match">‚úì Visual match ({vr["similarity"]:.2%} similar)</div>'
                else:
                    diff_img = ""
                    if vr.get("diff_image"):
                        diff_rel = Path(vr["diff_image"]).relative_to(self.output_dir)
                        diff_img = f'<div class="diff-image"><img src="{diff_rel}" alt="Diff"></div>'
                    vr_html = f'''<div class="vr-info diff">‚ö† Visual difference detected ({vr["similarity"]:.2%} similar)
                        <br>Different pixels: {vr["different_pixels"]:,}</div>{diff_img}'''

            results_html += f"""
            <div class="test-result {status_class}">
                <h3>{status_icon} {result["name"]}</h3>
                <p>{result.get("description", "")}</p>
                <p class="url">URL: {result["url"]}</p>
                <p class="meta">Format: {result.get("format", "png")} | Timestamp: {result["timestamp"]}</p>
                {vr_html}
                {error_html}
                <div class="screenshot">{screenshot_html}</div>
            </div>
            """

        # Add UI coverage details section
        ui_coverage_details = ""
        if self.ui_coverage_report and self.ui_coverage_report.get('untested'):
            untested_html = ""
            for elem in self.ui_coverage_report['untested'][:20]:  # Show max 20
                untested_html += f"""
                <tr>
                    <td>{elem['type']}</td>
                    <td><code>{elem['selector']}</code></td>
                    <td>{elem['text']}</td>
                    <td>{elem['file'].split('/')[-1]}</td>
                    <td>{elem['line']}</td>
                </tr>
                """

            ui_coverage_details = f"""
        <div class="ui-coverage-section">
            <h2>‚ö† Untested UI Elements ({self.ui_coverage_report['untested_elements']} found)</h2>
            <p>These elements exist in your source code but were not tested:</p>
            <table class="untested-table">
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Selector</th>
                        <th>Text</th>
                        <th>File</th>
                        <th>Line</th>
                    </tr>
                </thead>
                <tbody>
                    {untested_html}
                </tbody>
            </table>
        </div>
        """

        return f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Web App Test Report</title>
    <style>
        body {{ font-family: system-ui; background: #f5f5f5; padding: 20px; margin: 0; }}
        .container {{ max-width: 1400px; margin: 0 auto; }}
        header {{ background: white; padding: 30px; border-radius: 8px; margin-bottom: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .summary {{ display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; }}
        .summary-card {{ flex: 1; min-width: 150px; padding: 20px; border-radius: 6px; color: white; text-align: center; }}
        .summary-card h2 {{ margin: 0; font-size: 32px; }}
        .summary-card p {{ margin: 10px 0 0; font-size: 14px; opacity: 0.9; }}
        .summary-card.total {{ background: #3498db; }}
        .summary-card.success {{ background: #27ae60; }}
        .summary-card.error {{ background: #e74c3c; }}
        .summary-card.regression {{ background: #f39c12; }}
        .summary-card.network {{ background: #9b59b6; }}
        .summary-card.network-failed {{ background: #e67e22; }}
        .summary-card.coverage {{ background: #1abc9c; }}
        .summary-card.ui-coverage {{ background: #16a085; }}
        .summary-card.ui-untested {{ background: #e74c3c; }}
        .test-result {{ background: white; padding: 25px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .test-result.success {{ border-left: 4px solid #27ae60; }}
        .test-result.error {{ border-left: 4px solid #e74c3c; }}
        .test-result h3 {{ margin-top: 0; }}
        .screenshot img {{ width: 100%; border: 1px solid #ddd; border-radius: 4px; margin-top: 15px; }}
        .url {{ color: #666; font-size: 14px; }}
        .meta {{ color: #999; font-size: 12px; font-family: monospace; }}
        .error-msg {{ background: #fee; color: #c33; padding: 10px; border-radius: 4px; margin: 10px 0; }}
        .vr-info {{ padding: 10px; border-radius: 4px; margin: 10px 0; font-size: 14px; }}
        .vr-info.match {{ background: #d4edda; color: #155724; }}
        .vr-info.diff {{ background: #fff3cd; color: #856404; }}
        .vr-info.baseline {{ background: #d1ecf1; color: #0c5460; }}
        .diff-image img {{ width: 100%; border: 2px solid #f39c12; border-radius: 4px; margin-top: 10px; }}
        .ui-coverage-section {{ background: white; padding: 25px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .untested-table {{ width: 100%; border-collapse: collapse; margin-top: 15px; }}
        .untested-table th {{ background: #f8f9fa; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; }}
        .untested-table td {{ padding: 10px; border-bottom: 1px solid #dee2e6; }}
        .untested-table code {{ background: #f8f9fa; padding: 2px 6px; border-radius: 3px; font-size: 12px; }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé≠ Web App Test Report</h1>
            <p><strong>Base URL:</strong> {self.base_url}</p>
            <p><strong>Date:</strong> {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            {"<p><strong>Mode:</strong> Auto-Discovery</p>" if self.auto_discover else ""}
            <div class="summary">
                <div class="summary-card total"><h2>{len(self.test_results)}</h2><p>Total Tests</p></div>
                <div class="summary-card success"><h2>{successful}</h2><p>Successful</p></div>
                <div class="summary-card error"><h2>{failed}</h2><p>Failed</p></div>
                {visual_regression_html}
                {network_html}
                {coverage_html}
                {ui_coverage_html}
            </div>
        </header>
        {ui_coverage_details}
        {results_html}
    </div>
</body>
</html>"""


def load_config(config_file: str) -> Dict[str, Any]:
    """Load configuration from JSON or YAML file."""
    config_path = Path(config_file)

    if not config_path.exists():
        raise FileNotFoundError(f"Config file not found: {config_file}")

    with open(config_path, 'r') as f:
        if config_path.suffix in ['.yaml', '.yml']:
            return yaml.safe_load(f)
        elif config_path.suffix == '.json':
            return json.load(f)
        else:
            raise ValueError(f"Unsupported config format: {config_path.suffix}")


async def main():
    parser = argparse.ArgumentParser(description="Playwright Web Testing Tool with Auto-Discovery")
    parser.add_argument("--config", "-c", help="Config file (JSON or YAML)")
    parser.add_argument("--url", help="Base URL to test")
    parser.add_argument("--output", "-o", default="test_results", help="Output directory")
    parser.add_argument("--baseline", "-b", help="Baseline directory for visual regression")
    parser.add_argument("--format", "-f", choices=["png", "jpeg", "webp"], default="png", help="Screenshot format")
    parser.add_argument("--video", action="store_true", help="Enable video recording")
    parser.add_argument("--network-logs", action="store_true", help="Enable network logging")
    parser.add_argument("--coverage", action="store_true", help="Enable code coverage tracking")
    parser.add_argument("--device", "-d", choices=list(DEVICE_PRESETS.keys()), help="Device preset")
    parser.add_argument("--network", "-n", choices=list(NETWORK_PRESETS.keys()), help="Network preset")
    parser.add_argument("--parallel", "-p", type=int, default=1, help="Max parallel tests")
    parser.add_argument("--auto-discover", action="store_true", help="Automatically discover all pages and interactive elements")
    parser.add_argument("--max-depth", type=int, default=3, help="Max crawl depth for auto-discovery")
    parser.add_argument("--max-pages", type=int, default=100, help="Max pages to discover")
    parser.add_argument("--source-dir", help="Source code directory for UI coverage analysis")
    parser.add_argument("--ui-coverage", action="store_true", help="Enable UI coverage validation (compare code vs tests)")
    parser.add_argument("--before-after", action="store_true", help="Take before/after screenshots for each interaction")
    parser.add_argument("--list-devices", action="store_true", help="List available device presets")
    parser.add_argument("--list-networks", action="store_true", help="List available network presets")

    args = parser.parse_args()

    # List presets
    if args.list_devices:
        print("Available device presets:")
        for name, config in DEVICE_PRESETS.items():
            print(f"  {name}: {config['width']}x{config['height']} (mobile: {config['is_mobile']})")
        return

    if args.list_networks:
        print("Available network presets:")
        for name, config in NETWORK_PRESETS.items():
            print(f"  {name}: {config}")
        return

    # Load configuration
    if args.config:
        config = load_config(args.config)
        base_url = config.get("base_url", args.url)
        routes = config.get("routes", [])
        output_dir = config.get("output_dir", args.output)
        baseline_dir = config.get("baseline_dir", args.baseline)
        screenshot_format = config.get("screenshot_format", args.format)
        enable_video = config.get("enable_video", args.video)
        enable_network_logs = config.get("enable_network_logs", args.network_logs)
        enable_coverage = config.get("enable_coverage", args.coverage)
        device = config.get("device", args.device)
        network = config.get("network", args.network)
        max_parallel = config.get("max_parallel", args.parallel)
        auto_discover = config.get("auto_discover", args.auto_discover)
        max_depth = config.get("max_depth", args.max_depth)
        max_pages = config.get("max_pages", args.max_pages)
        source_dir = config.get("source_dir", args.source_dir)
        enable_ui_coverage = config.get("enable_ui_coverage", args.ui_coverage)
        before_after_screenshots = config.get("before_after_screenshots", args.before_after)
    else:
        # Default configuration
        base_url = args.url or "http://localhost:3000"
        routes = [] if args.auto_discover else [
            {"route": "/", "name": "home", "description": "Home page"},
            {"route": "/about", "name": "about", "description": "About page"},
        ]
        output_dir = args.output
        baseline_dir = args.baseline
        screenshot_format = args.format
        enable_video = args.video
        enable_network_logs = args.network_logs
        enable_coverage = args.coverage
        device = args.device
        network = args.network
        max_parallel = args.parallel
        auto_discover = args.auto_discover
        max_depth = args.max_depth
        max_pages = args.max_pages
        source_dir = args.source_dir
        enable_ui_coverage = args.ui_coverage
        before_after_screenshots = args.before_after

    if not base_url:
        print("Error: --url or --config with base_url is required")
        return

    # Run tests
    tester = WebAppTester(
        base_url=base_url,
        output_dir=output_dir,
        baseline_dir=baseline_dir,
        screenshot_format=screenshot_format,
        enable_video=enable_video,
        enable_network_logs=enable_network_logs,
        enable_coverage=enable_coverage,
        device=device,
        network=network,
        max_parallel=max_parallel,
        auto_discover=auto_discover,
        max_depth=max_depth,
        max_pages=max_pages,
        source_dir=source_dir,
        enable_ui_coverage=enable_ui_coverage,
        before_after_screenshots=before_after_screenshots,
    )

    await tester.run_tests(routes)
    print("\n‚úÖ Testing complete!")


if __name__ == "__main__":
    asyncio.run(main())
